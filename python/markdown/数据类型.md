### list
python内置的一种数据类型，列表。类似于js的数组，索引从0开始。list里面的元素的数据类型也可以是不同，list的某一项元素也可以是另一个list。如果list为空，则len(list)=0。list=[val1, val2, ...]
		
- len(list)函数可以获取list元素的个数
- list[索引值]，获取索引所对应的某一项，可以取负值，从-1开始。
- lsit.append(value)，往list的末尾追加
- list.insert(索引值，value)在索引值的前面添加
- list.pop()，删除list末尾一项，返回删除的那一项
- list.pop(索引值)，删除索引值所对应的一项，返回删除的那一项
- list[索引值]=value，重新赋值给对应的索引位置
- list.sort() 排序，当list中的元素类型不同时就不能排序

### tuple
有序列表，元组。类似于list，但是tuple一旦初始化就不能修改了，只可以获取上面的元素，不能对上面的元素重新赋值。这里的不变，指的是每个元素的指向不变，如果tuple中的元素是list，那么就可以改变list中的元素。tuple=(val1, val2, val3...)，当tuple为空时，可以写成()。如果只有一个元素，必须加上，tuple=(val1,)。

### 条件判断
```
if <条件判断1>:
    <执行1>
elif <条件判断2>:
    <执行2>
elif <条件判断3>:
    <执行3>
else:
    <执行4>
```
if语句执行有个特点，它是从上往下判断，如果在某个判断上是True，把该判断对应的语句执行后，就忽略掉剩下的elif和else。当变量是非零数值，非空字符串，非空对象都为True；数字0，空对象，以及None都为False。 input()返回的数据类型是str，如果与数字进行比较就必须用int()进行转换。
			
### 布尔运算
x and y。从左到右，找到布尔值是False的那一项，如果没有就返回最后一项 \
x or y。从左到右，找到布尔值是True的那一项，如果没有就返回最后一项 \
bool(val)， 将值进行布尔转换，转换成true或者false。

### 循环
python的循环有两种，一种是for..in循环，依次把list或tuple中的每一个元素迭代出来。range(val)函数可以生成一个小于val的整数序列，也可以用于循环的对象。 for...in range(val).另一种就是while循环，只要条件满足，就不断地循环，条件不满足就退出循环。

### dict
Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。字典的索引表里（比如部首表）查这个字对应的页码，然后直接翻到该页，找到这个字。无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢。

类似于js中的对象，只是字典中没有的key，进行取值时，就会报错，因此需要避免key不存在的错误，一种方法是通过in判断key是否存在:'key' in dict 返回布尔值True或者False;另一种方法是通过dict提供的get方法，如果key不存在，可以返回None，或者自己指定的value，返回None的时候Python的交互式命令行不现实结果。dict.get(key, 指定的value)

dict.pop(key)删除key以及对应的value，反悔的结果是删除的key所对应的value的值。

dict内部的存放顺序和key放入的顺序是没有关系的，和list相比较，dict有以下几个特点：1.查找和插入的速度极快，不会随着key的增加而变慢;2.需要占用大量的内存，内存浪费的多。而list则相反，1.查找和插入的时间随着元素的增加而增加；2.占用空间小，浪费内存很少。所以，dict使用 空间来换取时间的一种方法。

dict可以用在需要快速查找的地方，dict的key必须是不可变对象。这是因为dict根据key来计算value的储存位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了，这种通过key计算位置的算法称为哈希算法（hash）。要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key。
		
### set
set和dict，也是一组key的集合，但不存储value，由于key不能重复，由于key不能重复，所以，在set中，没有重复的key，set的显示结果是用{}包起来的，set(list)返回{val1，val2}，传入的[val1, val2]是一个list，而显示的{val1, val2}只是展示这个set内部有val1，val2，现实的顺序也不表示set是有序的。

重复的元素在set中自动过滤，set(list)如果list中有重复的元素会被自动过滤掉。

set可以看成数学意义上的无序和无重复的集合，因此两个set可以做数学意义上的交集、并集等操作。s1=set(list1),s2=set(list2); s1 & s2 返回s1和s2的交集， s1 | s2 返回s1和s2的并集。

set和dict的唯一区别仅在于没有储存对应的value，但是，set和dict的原理是一样的，同样不可放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。
- set.add(key) 添加元素到set中，可以重复添加，但不会有结果
- set.remove(key) 删除元素

### 不可变对象
> str.replace('str中的连续字符串', '替换的结果')， 如果第一个值不存在，则返回str，否则返回替换后的结果，而原本的str并没有变。

a='qwe','qwe'才是字符串对象，a的本身是一个变量，它指向的对象的内容才是'qwe',a.replace('q','Q')时，实际上是调用replace作用在字符串对象'qwe'上的。
		
### 所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。
	