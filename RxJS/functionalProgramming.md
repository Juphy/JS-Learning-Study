## 函数式编程

函数式编程是一种 "编程范式"（programming paradigm），也就是如何编写程序的方法论。它属于 "结构化编程" 的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用。

OOP自顶向下架构层层分解（解构），FP自底向上层层组合（复合），而实质上，编程的本质就是次化分解与复合的过程。

在OOP中，一个理想的对象应该是只暴露它的抽象接口，其方法则扮演箭头的角色。FP通过函数组合来构造其逻辑系统，倾向于把软件分解为其需要执行的行为或操作，而且通常采用自底向上的方法。函数式编程提供了非常强大的对事物进行抽象和组合的能力。

OOP中很多所谓面向对象设计模式，因为面向对象语言没有first-class function（对应的多态性），所以导致了每个函数必须被包在一个对象里面（受约束的函数指针）才能传递到其它地方。

### 函数与映射
一切皆是映射。函数式编程的代码主要就是“对映射的描述”，组合是编程的本质，其实，组合就是建立映射关系，组合的本质是范畴。将问题不断加以抽象从而将本质问题抽取出来加以论证解决。

一个函数无非就是从输入到输出的映射，数学表达式就是：
```
f: x -> y
p: y -> z
p(f): x -> z
```
用编程语言表达就是：
```
fun f(x: X): Y{}
fun p(y: Y): Z{}
fun fp(f: (X) -> Y, p: (Y) -> Z): Z){
    return {x -> p(f(x))}
}
```
### 函数是“第一等公民”
指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为其它函数的返回值。当编程语言将函数视为“第一等公民”，那么相当于它支持`高阶函数`（`高阶函数`：接受一个或多个函数作为输入；输出一个函数），高阶函数就是多阶映射。
```
numberList = [0,1,2,3,4,5,6,7,8,9]
分别实现对每个元素的操作
def map(fn, ary)
    newList=[];
    for num in  numberList:
        newList.append(fn(num))

map(lambda x: x+1, numberList) // lambda关键字用于定义一个匿名函数，x表示输入，冒号后是函数体同时也是返回值。
```

```
var fn=function(i){console.log(i)};
[1,2,3].forEach(fn);
// fn变量就是一个函数，可以作为一个函数的参数
```
### 函数柯理化（currying）
用一元函数，来组合成多元函数。currying将接受多个参数的函数变换成接受其中部分参数，并且返回接受余下参数的新函数。currying完成的事情就是函数（接口）封装，它将一个已有的函数（接口）做封装，得到一个新的函数（接口）。currying的工程实用性、简洁性上不是那么友好，大量使用currying，会导致代码可读性降低，复杂性增加。

### 闭包（Closure）
简单讲就是一个代码块，用{}包起来，此时，程序代码就成了数据，可以被一个变量所引用，闭包最典型的应用就是实现回调函数。

### Memoization技术
提升性能，满足引用透明的表达式，就是任意两次调用只要输入相同，其结果总是不变的，于是可以将第一次的结果缓存起来，遇到下一次执行时直接替换，依然能保证程序的正确性。

### 延迟求值（Lazy Evaluation）
表达式不在它被绑定到变量时就立即求值，而是在该值被用到的时候才计算求值，延迟求值有利于程序性能的提升。延迟求值的最大好处就是利于模块化。

```
输出斐波那契数列的第10到20，前十个偶数，前5个能被3整除的数
fiboSequence = createFibonacci()
fiboSequence[10: 20] # 数列第20个之后的不会计算

evenFiboSequence = pickEven（fiboSequence）#挑选偶数
evenFiboSequence[0: 10]

newList = pick3(fiboSequence)
newList[0: 5]
```
- 函数式编程语言主张将函数写成`纯函数`(pure function)
    - 函数的结果只依赖于输入的参数且与外部系统状态无关——只要输入相同，返回值总是不变的
    - 除了返回值外，不修改程序的外部状态（全局的变量，入参）——满足这一条件也被称作“没有副作用（side effect）”
- `引用透明`：如果一个表达式，对于相同的输入，总是有相同的结果并且不修改程序其他部分的状态，那么这个表达式是引用透明的。
- 并发执行

> 只用“表达式”，不用“语句”(Expression, no Statement)

“表达式”是一个单纯的运算过程，总是有返回值；“语句”是执行某些操作，没有返回值。函数式编程要求，只使用表达式，不适用语句，也就是说，每一步都是单纯的运算，而且都有返回值。原因是函数式编程的开发动机，已开始就是为了处理运算，不考虑系统的读写（I/O）。“语句”属于对系统的读写操作，所以就被排斥在外。但是在实际中，不做I/O是不可能的，因此编程过程中，函数式编程只要求把I/O限制到最小，不要有不必要的读写行为，保持运算过程的单纯性。

> 没有“副作用”（no side effects）

副作用：指的是函数内部与外部互动（最典型的情况就是修改全局变量的值），产生运算以外的其他结果。函数式编程强调没有“副作用”，函数保持独立，所有的功能就是返回一个新值，没有其他行为，尤其是不得修改外部变量的值。

> 不修改状态，利用参数保存状态 

在其他类型的语言中，变量往往用来保存状态（state），不修改变量，意味着状态不能保存在变量中，函数式编程使用参数保存状态。
```
function reverse(string){
    if(string.length==0){
        return string;
    }else{
        return reverse(string.substring(1, string.length)) + string.substring(0,1);
    }
}
```
> 引用透明（Referential transparency）

指的是函数的运行不依赖与外部变量或状态，只依赖于传入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。

### Functional Programming的优势
- 可读性高：当我们通过一系列的函式封装资料的操作过程，代码变得非常的简洁且可读性极高。
- 可维护性高：因为pure function等特性，执行结果不依赖外部状态，且不会对外部环境有任何操作，使functional programming能更好的出错及撰写单元测试。
- 易于并行/平行处理：functional programming易于做并行/平行（Concurrency/Parallel）处理，不必担心deadlock等问题。

### Functional Programming通用函式

- forEach
- map
- filter
- concatAll（把一个二维整列转为一维）
```
Array.prototype.concatAll=function(){
    let res=[];
    this.forEach(array =>{
        res.push.apply(res, array);
    });
    return res;
}
```